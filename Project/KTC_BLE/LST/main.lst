C51 COMPILER V9.59.0.0   MAIN                                                              12/21/2018 14:01:32 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Output\main.obj
COMPILER INVOKED BY: D:\program files\Keil\C51\BIN\C51.EXE Source\main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Include) 
                    -DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\main.lst) TABS(2) OBJECT(.\Output\main.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --
   2          IDE information
   3          
   4          IDE-Version:
   5          uVision V5.23.0.0
   6          Copyright (C) 2017 ARM Ltd and ARM Germany GmbH. All rights reserved.
   7          
   8          License Information:
   9          Junpu Xu
  10          EasyRD
  11          LIC=D0MII-T15AM-B0TNC-7EV6U-BMK3S-W19YC
  12          
  13          Tool Version Numbers:
  14          Toolchain:        PK51 Prof. Developers Kit  Version: 9.00
  15          Toolchain Path:    D:\program files\Keil\C51\BIN
  16          C Compiler:         C51.exe    V9.00
  17          Assembler:          A51.exe    V8.01
  18          Linker/Locator:     BL51.exe    V6.22
  19          Librarian:             LIB51.exe    V4.24
  20          Hex Converter:      OH51.exe    V2.6
  21          CPU DLL:               S8051.DLL            V3.72
  22          Dialog DLL:         DP51.DLL             V2.59
  23          Target DLL:             Nuvoton_8051_Keil_uVision_Driver.dll      V1.09
  24          Dialog DLL:         TP51.DLL             V2.58
  25          --------------------------------------------------------------------------------*/
  26          
  27          
  28          /*----------------------------------Software version record -------------------------------------
  29          v0.0.0  2018_03_21
  30          v0.0.1,2018_12_14
  31            -- MCU can talk with BT module (Mesh function of BT module not yet tested)
  32          
  33          v0.0.2,2018_12_17
  34            -- Two nodes mesh network built-up
  35          
  36          v0.2.3 2018_12_19
  37            --test Github
  38          ----------------------------------------------------------------------------------------------------------
             ---*/
  39          //********************************************************************************************************
             -***
  40          
  41          //********************************************************************************************************
             -***
  42          // 
  43          //********************************************************************************************************
             -***
  44          #include "N76E003.h"
  45          #include "SFR_Macro.h"
  46          #include "Common.h"
  47          #include "Delay.h"
  48          #include "string.h"
  49          #include "Function_define.h"
C51 COMPILER V9.59.0.0   MAIN                                                              12/21/2018 14:01:32 PAGE 2   

  50          
  51          #define BUFFER_SIZE   16
  52          UINT8  UART_BUFFER[BUFFER_SIZE],temp;
  53          UINT16 u16_CNT=0,u16_CNT1=0;
  54          bit riflag;
  55          
  56          #define TxBufferSize  50
  57          #define RxBufferSize  50
  58          
  59          struct Mesh_Data_Send
  60          {
  61            UINT16  Instruction;
  62            UINT16  Target_Short_Address;
  63            UINT8 DATA[10];
  64            //UINT8 DATA[10] = {1,2,3,4,5,6,7,8,9,0x0A};
  65          } Mesh_Data_Send_1;
  66          
  67          #define Instruction_Send  0xAAFB
  68          #define Address_Broadcast 0xFFFF
  69          
  70          UINT8 xdata TxBuffer[TxBufferSize]; 
  71          UINT8 xdata RxBuffer[RxBufferSize];
  72          volatile UINT8 RxBuffer_read_counter = 0x00;
  73          volatile UINT8 RxBuffer_write_counter = 0x00;
  74          volatile UINT8 TxBuffer_read_counter = 0x00;
  75          volatile UINT8 TxBuffer_write_counter = 0x00;
  76          
  77          void v_init();
  78          void v_Load_Mesh_Send_Data(UINT16 Instruction,UINT16 Address,UINT8 Data[]);
  79          
  80          /**
  81           * FUNCTION_PURPOSE: serial interrupt, echo received data.
  82           * FUNCTION_INPUTS: P0.7(RXD) serial input
  83           * FUNCTION_OUTPUTS: P0.6(TXD) serial output
  84           */
  85          void SerialPort0_ISR(void) interrupt 4 
  86          {
  87   1        if (RI==1)
  88   1        {                                       /* if reception occur */
  89   2          clr_RI;                             /* clear reception flag for next reception */
  90   2          RxBuffer[RxBuffer_write_counter] = SBUF;
  91   2          
  92   2          //SBUF = RxBuffer[RxBuffer_write_counter];
  93   2          
  94   2          RxBuffer_write_counter ++;
  95   2          if(RxBuffer_write_counter >= RxBufferSize)
  96   2          {
  97   3            RxBuffer_write_counter = 0;
  98   3          }
  99   2      
 100   2          riflag =1;
 101   2          
 102   2          
 103   2          }
 104   1          if(TI==1)
 105   1        {
 106   2          clr_TI;                             /* if emission occur */
 107   2          if(TxBuffer_read_counter != TxBuffer_write_counter)
 108   2          {
 109   3            SBUF = TxBuffer[TxBuffer_read_counter];
 110   3            TxBuffer_read_counter ++;
 111   3            if(TxBuffer_read_counter >= TxBufferSize)
C51 COMPILER V9.59.0.0   MAIN                                                              12/21/2018 14:01:32 PAGE 3   

 112   3            {
 113   4              TxBuffer_read_counter = 0;
 114   4            }
 115   3          } 
 116   2        }
 117   1      }
 118          
 119          char putchar (char c)
 120          {
 121   1      //    while (!TI_1);  /* wait until transmitter ready */
 122   1        TxBuffer[TxBuffer_write_counter] = c;
 123   1        TxBuffer_write_counter ++;
 124   1        if(TxBuffer_write_counter >= TxBufferSize)
 125   1        {
 126   2          TxBuffer_write_counter = 0;
 127   2        }
 128   1          
 129   1          //SBUF = c;      /* output character */
 130   1          return (c);
 131   1      }
 132          
 133          void v_Load_Mesh_Send_Data(UINT16 Instruction,UINT16 Address,UINT8 Data[])
 134          {
 135   1        UINT8 temp_Mesh_Send_Data,i_Mesh_Send_Data;
 136   1      
 137   1        //load instruction
 138   1        temp_Mesh_Send_Data = (Instruction >> 8) & 0xFF;
 139   1        putchar(temp_Mesh_Send_Data); 
 140   1        temp_Mesh_Send_Data = Instruction & 0xFF;
 141   1        putchar(temp_Mesh_Send_Data);
 142   1        
 143   1        //load address
 144   1        temp_Mesh_Send_Data = (Address >> 8) & 0xFF;
 145   1        putchar(temp_Mesh_Send_Data); 
 146   1        temp_Mesh_Send_Data = Address & 0xFF;
 147   1        putchar(temp_Mesh_Send_Data); 
 148   1        
 149   1        //load data
 150   1        //10 bytes data
 151   1        for(i_Mesh_Send_Data = 0;i_Mesh_Send_Data < 10; i_Mesh_Send_Data++)
 152   1        {
 153   2          putchar(Data[i_Mesh_Send_Data]);
 154   2        }
 155   1        
 156   1        
 157   1      }
 158          
 159          //v_init() function
 160          void v_init()
 161          { 
 162   1        set_CLOEN;  //Clock Output Enable
 163   1        
 164   1        /*BT module PWRC pin configuration
 165   1          Connect state:
 166   1              --PWRC = 1:Transparent transmission
 167   1              --PWRC = 0:AT instruction/Querry. 
 168   1                        In this sate, BT device (MP for instance) can still send data via BT module to MCU, 
 169   1                        but BT does not forward data from MCU to MP(BT device)
 170   1          Unconnect state:
 171   1              --PWRC = 1:AT instruction/Querry
 172   1              --PWRC = 0:AT instruction/Querry  
 173   1        */
C51 COMPILER V9.59.0.0   MAIN                                                              12/21/2018 14:01:32 PAGE 4   

 174   1        P14_PushPull_Mode;    //P14 for BT's PWRC pin
 175   1        
 176   1          P12_PushPull_Mode;
 177   1      
 178   1          
 179   1      
 180   1        InitialUART0_Timer3(115200);
 181   1      
 182   1        
 183   1      
 184   1      
 185   1      
 186   1          
 187   1          set_RB8;          //This bit is for setting the stop bit 2 high/low status,  */
 188   1          clr_TI; 
 189   1          set_ES;           //enable UART interrupt
 190   1          set_EA;           //enable global interrupt
 191   1      }
 192          
 193          /*********************************************************************************************************
             -***
 194          *    Main function 
 195          **********************************************************************************************************
             -**/
 196          void main (void)
 197          {
 198   1        UINT8 i;
 199   1        UINT8 Data_Test[16] = {"FUCK56789A"};
 200   1        //char *Data_Test1[16];
 201   1        
 202   1        
 203   1        v_init();
 204   1      
 205   1          while(1)
 206   1          {
 207   2            if (riflag)
 208   2            {
 209   3              P12 = ~P12;   //In debug mode check UART_BUFFER[u16_CNT] to check receive data
 210   3              riflag = 0;
 211   3            }
 212   2            
 213   2            //Send_Data_To_UART0(0x55);
 214   2            //putchar(0x55);
 215   2            
 216   2            
 217   2            //printf("\n temp= 0x%bX",0x55);
 218   2            
 219   2            //Querry Version number
 220   2            //Response:JDY-10M-Y2.2-MESH
 221   2            //printf("AT+VER\r\n");
 222   2            
 223   2            //Querry MAC address
 224   2            //Response:+MAC:<mac address>
 225   2            //printf("AT+MAC\r\n");
 226   2          
 227   2      
 228   2            //SET BT address
 229   2            //Response:+OK
 230   2      /*      printf("AT+NAMEKTC-BT-MESH-1\r\n"); 
 231   2            TI = 1; //Triggering UART buffer sending process ... for putchar() & Printf()
 232   2            Timer0_Delay1ms(200); 
 233   2            Timer0_Delay1ms(2);  */     
C51 COMPILER V9.59.0.0   MAIN                                                              12/21/2018 14:01:32 PAGE 5   

 234   2      
 235   2            
 236   2      
 237   2            //Querry BT address
 238   2            //Response:+NAME=<BT name>
 239   2      /*      printf("AT+NAME\r\n");
 240   2            TI = 1; //Triggering UART buffer sending process ... for putchar() & Printf()
 241   2            Timer0_Delay1ms(200); 
 242   2            Timer0_Delay1ms(2);    */ 
 243   2            
 244   2            //Querry BAUD rate
 245   2            //Response:+BAUD=<0--115200>
 246   2            //printf("AT+BAUD\r\n");  
 247   2      
 248   2            //Set device type
 249   2            //Response:+ok
 250   2            /*
 251   2                A0:Transparent transmission mode
 252   2                B1:LED light mode
 253   2                C0:Low power consumption telecontroller     
 254   2            */
 255   2            //printf("AT+CLSSA0\r\n");
 256   2              
 257   2      
 258   2            //clr_P14;
 259   2            set_P14;
 260   2      
 261   2            //Querry device type
 262   2            //Response:+CLSS=<A0--Transparent transmission mode>
 263   2            //printf("AT+CLSS\r\n");
 264   2            
 265   2            //SET mesh network ID 
 266   2            //(ID has to be exactly 12 characters, if not enough, fill in with space)
 267   2            //(ID has to be data within 0-9,A,B,C,D,E,F)
 268   2            //Response:+OK
 269   2            //printf("AT+NETID0123456BCDEF\r\n"); 
 270   2            //TI = 1; //Triggering UART buffer sending process ... for putchar() & Printf()
 271   2            //Timer0_Delay1ms(200); 
 272   2            //Timer0_Delay1ms(2);       
 273   2            
 274   2          
 275   2      
 276   2            //Querry mesh network ID
 277   2            //Response:+NETID=<netID>
 278   2            //printf("AT+NETID\r\n");   
 279   2            //TI = 1; //Triggering UART buffer sending process ... for putchar() & Printf()
 280   2            //Timer0_Delay1ms(200); 
 281   2            //Timer0_Delay1ms(2);     
 282   2      
 283   2            //SET mesh network short address
 284   2            //(short address has to be exactly 2 characters, if not enough, fill in with space)
 285   2            //(short address has to be data within 0-9,A,B,C,D,E,F)
 286   2            //Response:+OK
 287   2            //printf("AT+MADDR55\r\n"); 
 288   2            //TI = 1; //Triggering UART buffer sending process ... for putchar() & Printf()
 289   2            //Timer0_Delay1ms(200); 
 290   2            //Timer0_Delay1ms(2);       
 291   2            
 292   2      
 293   2            //Querry mesh network short address
 294   2            //Response:+MADDR=<short address>
 295   2            //printf("AT+MADDR\r\n"); 
C51 COMPILER V9.59.0.0   MAIN                                                              12/21/2018 14:01:32 PAGE 6   

 296   2            //TI = 1; //Triggering UART buffer sending process ... for putchar() & Printf()
 297   2            //Timer0_Delay1ms(200); 
 298   2            //Timer0_Delay1ms(2);     
 299   2            
 300   2            //SET APP connection passcode
 301   2            //(APP connection passcode has to be exactly 4 characters, if not enough, fill in with space)
 302   2            //(APP connection passcode can be any asCII code)
 303   2            //Response:+OK
 304   2      /*      printf("AT+PSS8HAB\r\n");         
 305   2            TI = 1; //Triggering UART buffer sending process ... for putchar() & Printf()
 306   2            Timer0_Delay1ms(200); 
 307   2            Timer0_Delay1ms(2);    */ 
 308   2      
 309   2            //Querry APP connection passcode
 310   2            //Response:+PSS=<passcode>
 311   2      /*      printf("AT+PSS\r\n");
 312   2            TI = 1; //Triggering UART buffer sending process ... for putchar() & Printf()
 313   2            Timer0_Delay1ms(200); 
 314   2            Timer0_Delay1ms(2); */        
 315   2      
 316   2            //SET APP passcode connection switch
 317   2            //ISCEN0 -- APP dosn't require a passcode
 318   2            //ISCEN1 -- open APP passcode switch
 319   2            //Response:+OK
 320   2      /*      printf("AT+ISCEN0\r\n");  
 321   2            TI = 1; //Triggering UART buffer sending process ... for putchar() & Printf()
 322   2            Timer0_Delay1ms(200); 
 323   2            Timer0_Delay1ms(2);       
 324   2             */
 325   2          
 326   2      
 327   2            //Querry APP passcode connection switch
 328   2            //Response:+ISCEN=<ISCEN>
 329   2            //            0 -- APP dosn't require a passcode
 330   2            //            1 -- open APP passcode switch
 331   2      /*      printf("AT+ISCEN\r\n"); 
 332   2            TI = 1; //Triggering UART buffer sending process ... for putchar() & Printf()
 333   2            Timer0_Delay1ms(200);     
 334   2            Timer0_Delay1ms(2);  */
 335   2            
 336   2            //Broadcast send data
 337   2      /*      putchar(0xAA);
 338   2            putchar(0xFB);
 339   2            putchar(0xFF);
 340   2            putchar(0xFF);
 341   2            printf("123456789A"); */
 342   2            strcpy(Data_Test,"IAMNOTFINEOK");     
 343   2            v_Load_Mesh_Send_Data(Instruction_Send,Address_Broadcast,Data_Test);
 344   2            
 345   2            //*Data_Test1 = "IAMNOTFINEOK";
 346   2            //v_Load_Mesh_Send_Data(Instruction_Send,Address_Broadcast,Data_Test1);
 347   2      
 348   2            
 349   2            TI = 1; //Triggering UART buffer sending process ... for putchar() & Printf()
 350   2            Timer0_Delay1ms(200);     
 351   2            Timer0_Delay1ms(2); 
 352   2            
 353   2            //printf(0x55);
 354   2            
 355   2            TI = 1; //Triggering UART buffer sending process ... for putchar() & Printf()
 356   2            //P12 = ~P12;   //In debug mode check UART_BUFFER[u16_CNT] to check receive data
 357   2            
C51 COMPILER V9.59.0.0   MAIN                                                              12/21/2018 14:01:32 PAGE 7   

 358   2            Timer0_Delay1ms(200);   
 359   2            Timer0_Delay1ms(2);   
 360   2          }
 361   1        
 362   1      }
*** WARNING C280 IN LINE 198 OF Source\main.c: 'i': unreferenced local variable
 363          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    351    ----
   CONSTANT SIZE    =     29    ----
   XDATA SIZE       =    100    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     39      22
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
